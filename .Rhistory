install.packages("sna")
install.packages("sna")
# install.packages("sna")
library(sna)
e
res.righttroll.contagion <- BayesALAAM(y = fg.righttroll, # median-based dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 1000,   # number of iterations
saveFreq = 200)   # print and save frequency
source('MultivarALAAMalt.R')
source('MultivarALAAMalt.R')
res.righttroll.contagion <- BayesALAAM(y = fg.righttroll, # median-based dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 1000,   # number of iterations
saveFreq = 200)   # print and save frequency
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.righttroll.contagion$Thetas)
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = followinggrowth,           # dependent variable
ADJ = adj,           # network
covariates = covs[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj,           # network
covariates = covs[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
## Plot the MCMC output in trace plots
plot(ts(res.righttroll.contagion$Thetas))
class(adj.righttroll)
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
plot(ts(res.rt$Thetas))
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 3500,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 5000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
plot(ts(res.rt$Thetas))
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 5000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 7000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
plot(ts(res.rt$Thetas))
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 8000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 7000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
plot(ts(res.rt$Thetas))
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6500,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
plot(ts(res.rt$Thetas))
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6500,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
## which can be used as an argument PropSigma to BayesALAAM. This proposal
## variance (covariance) matrix, directly regulates how big jumps we are
## proposing, as discussed above in the section on ESS.
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6500,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
# good models
res.rt1 <- res.rt
res.rt1
Propsigma <- cov(res.rt$Thetas)
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6800,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
# ESS - intercept, outdegree, twopath
# SACF10 - intercept, contagion, outdegree, twopath
# SACF30 -
res.rt2 <- res.rt
Propsigma <- cov(res.rt$Thetas)
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6700,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
Propsigma <- cov(res.rt$Thetas)
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6900,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
# ESS -
# SACF10 - outdegree, reciprocation
# SACF30 - reciprocation
res.rt3 <- res.rt #6900
summary(fg.righttroll) # the mean is 2719,but the median is 19.
# creating measure of dv
fg.righttroll <- maxfollowers - minfollowers
summary(fg.righttroll) # the mean is 2719,but the median is 19.
# From Milton:  Hi teammates, the overall "mean is 2962, median is 581.5" Obviously, the right and left trolls have very different distributions.  Let me try the right troll
# recoding followinggrowth
fg.righttroll[fg.righttroll<19] <- 0
fg.righttroll[fg.righttroll>=19] <- 1
summary(fg.righttroll)
str(fg.righttroll)
res.rt3
res.rt3
res.rt2
Propsigma <- cov(res.rt$Thetas)
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 7000,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
res.rt <- BayesALAAM(y = fg.righttroll,           # dependent variable
ADJ = adj.righttroll,           # network
covariates = covs.righttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,    # directed / undirected network
Iterations = 6850,   # number of iterations
saveFreq = 500,     # print and save frequency
PropSigma = Propsigma )
View(twitterAuth)
View(twitterData)
## Plot the MCMC output in trace plots
plot(ts(res.rt4$Thetas))
# ESS -
# SACF10 - intercept, activity
# SACF30 - intercept, activity, outdegree, twopath
res.rt4 <- res.rt #6850
## Plot the MCMC output in trace plots
plot(ts(res.rt4$Thetas))
# results of "res.righttroll.noncontagion2"
write.res.table(burnin=1, # should be set sufficiently high
datamat=res.rt4$Thetas, # the result from BayesALAAM
thin=1, # should be set so that SACF is sufficiently low,
# important for Confidence Intervals
tabname=NULL) # the name appended to the table that is saved
## Plot the MCMC output in trace plots
plot(ts(res.rt4$Thetas))
## Based on the posterior draws in res.0$Thetas, draw outcomes
## for goodness-of-fit for model "res.righttroll.noncontagion2"
sim.rt <- get.gof.distribution(NumIterations=500, # number of vectors to draw
res=res.rt4, # the ALAAM estimation object that contains model and results
burnin=100, # no. iterations discarded from GOF distribution
thinning = 1000) #, # no. iterations between sample points
gof.table(obs.stats= sim.rt$stats, # observed statistics included not
# fitted statistics
sim.stats= sim.rt$Sav.gof, # simulated goodness-of-fit statistics
name.vec= sim.rt$gof.stats.names, # names of statistics calculate,
# not all will be used if undirected
tabname='ALAAMGoFRightTroll', # name of file saved
pvalues=TRUE, # posterior predictive p-values
# save.tab ='csv', # save a csv file or a LaTex file
directed=TRUE)
# make lefttroll only data source
name <- get.vertex.attribute(trolls, "vertex.names")
accountcategory <- get.vertex.attribute(trolls, "accountcategory")
df <- data.frame(name = name, cat = accountcategory) #to create a dataframe
vertex.lefttroll <- df[(df$cat%in%c("LeftTroll")), "name"]
trollssample.lefttroll <- get.inducedSubgraph(trolls,v=which(trolls %v% "accountcategory"%in%c("LeftTroll")))
# make an adjacency matrix of network
adj.lefttroll <- as.matrix.network.adjacency(trollssample.lefttroll)
m <- nrow(adj.lefttroll) # check how many rows are there
m # this number is important, it is different from n in upper data
gplot(adj.lefttroll)
# Creating context-specific covariates for covs table that will be used for ALAAM ()
accountcategory <- get.vertex.attribute(trollssample.lefttroll,"accountcategory")
activity <- get.vertex.attribute(trollssample.lefttroll,"activity")
language <- get.vertex.attribute(trollssample.lefttroll,"language")
maxfollowing <- get.vertex.attribute(trollssample.leftttroll,"maxfollowing")
minfollowing <- get.vertex.attribute(trollssample.lefttroll,"minfollowing")
maxfollowers <- get.vertex.attribute(trollssample.lefttroll,"maxfollowers")
minfollowers <- get.vertex.attribute(trollssample.lefttroll,"minfollowers")
# Creating monadic covariates for covs.righttroll table that will be used for ALAAM
out.degree <-matrix( rowSums(adj.lefttroll), m, 1) # number of ties sent
in.degree <- matrix( colSums(adj.lefttroll) , m, 1 ) # number of ties received
rec.ties <-  matrix( rowSums(adj.lefttroll * t(adj.lefttroll) ), m , 1) # number of ties that are mutual
in.two.star <- matrix( choose(in.degree,2),m,1) #  in-stars refecting dispersion in popularity
out.two.star <- matrix( choose(out.degree,2),m,1) #  out-stars refecting dispersion in activity
mix.two.star <- in.degree*out.degree - rec.ties # correlation between indegree and outdegree
in.three.star <- matrix( choose(in.degree,3),m,1) # furhter measure of in-degree heterogeneity
out.three.star <- matrix( choose(out.degree,3),m,1) # furhter measure of out-degree heterogeneity
triangles <- rowSums( adj.lefttroll* (adj.lefttroll %*% t(adj.lefttroll) )  ) # embedded in transitive triads
## Forming a new covs
covs.lefttroll <- cbind(
activity,
maxfollowing,
minfollowing,
maxfollowers,
minfollowers,
in.degree,
out.degree,
rec.ties,
in.two.star,
out.two.star,
mix.two.star,
in.three.star,
out.three.star,
triangles)
colnames(covs.lefttroll) <- c(
"activity",
"maxfollowing",
"minfollowing",
"maxfollowers",
"minfollowers",
"indegree",
"outdegree",
"reciprocation" ,
"instar",
"outstar",
"twopath",
"in3star",
"out3star",
"transitive")
head(covs.lefttroll)
# creating measure of dv
fg.lefttroll <- maxfollowers - minfollowers
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
str(fg.righttroll)
summary(fg.righttroll)
str(fg.righttroll)
str(fg.lefttroll)
fg.lefttroll[fg.lefttroll<702] <- 0
fg.lefttroll[fg.lefttroll>=702] <- 1
summary(fg.lefttroll)
str(fg.righttroll)
str(fg.lefttroll)
gplot(adj.righttroll)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 1000,   # number of iterations
saveFreq = 200)   # print and save frequency
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.lt$Thetas)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 1000,   # number of iterations
saveFreq = 200)   # print and save frequency
class(adj.lefttroll)
fg.lefttroll
adj.lefttroll
covs.lefttroll[,c(1,6,7,8,11,14)]
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 5000,   # number of iterations
saveFreq = 200)   # print and save frequency
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
# creating measure of dv
fg.lefttroll <- maxfollowers - minfollowers
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
fg.lefttroll[fg.lefttroll<392] <- 0
fg.lefttroll[fg.lefttroll>=392] <- 1
summary(fg.lefttroll)
str(fg.lefttroll)
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.lt$Thetas)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 1000,   # number of iterations
saveFreq = 500)   # print and save frequency
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.lt$Thetas)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 6800,   # number of iterations
saveFreq = 500)   # print and save frequency
comp <- components(trollssample.lefttroll)
summary(trolls)
library(network)
# install.packages("ggplot2")
library(ggplot2)
# install.packages("stringr")
library(stringr)
# install.packages("sna")
library(sna)
# install.packages("mvtnorm")
library(mvtnorm)
# install.packages("xtable")
library(xtable)
# install.packages("network")
library(network)
source('MultivarALAAMalt.R')
# make lefttroll only data source
trollssample.lefttroll <- get.inducedSubgraph(trolls,v=which(trolls %v% "accountcategory" %in%c("LeftTroll")))
###############################################################################
# Load Trolls Rdata
###############################################################################
load("trolls.Rdata")
# make lefttroll only data source
trollssample.lefttroll <- get.inducedSubgraph(trolls,v=which(trolls %v% "accountcategory" %in%c("LeftTroll")))
# make an adjacency matrix of network
adj.lefttroll <- as.matrix.network.adjacency(trollssample.lefttroll)
m <- nrow(adj.lefttroll) # check how many rows are there
m # this number is important, it is different from n in upper data
gplot(adj.lefttroll)
# Creating context-specific covariates for covs table that will be used for ALAAM ()
accountcategory <- get.vertex.attribute(trollssample.lefttroll,"accountcategory")
activity <- get.vertex.attribute(trollssample.lefttroll,"activity")
language <- get.vertex.attribute(trollssample.lefttroll,"language")
maxfollowing <- get.vertex.attribute(trollssample.leftttroll,"maxfollowing")
minfollowing <- get.vertex.attribute(trollssample.lefttroll,"minfollowing")
maxfollowers <- get.vertex.attribute(trollssample.lefttroll,"maxfollowers")
minfollowers <- get.vertex.attribute(trollssample.lefttroll,"minfollowers")
# Creating monadic covariates for covs.righttroll table that will be used for ALAAM
out.degree <-matrix( rowSums(adj.lefttroll), m, 1) # number of ties sent
in.degree <- matrix( colSums(adj.lefttroll) , m, 1 ) # number of ties received
rec.ties <-  matrix( rowSums(adj.lefttroll * t(adj.lefttroll) ), m , 1) # number of ties that are mutual
in.two.star <- matrix( choose(in.degree,2),m,1) #  in-stars refecting dispersion in popularity
out.two.star <- matrix( choose(out.degree,2),m,1) #  out-stars refecting dispersion in activity
mix.two.star <- in.degree*out.degree - rec.ties # correlation between indegree and outdegree
in.three.star <- matrix( choose(in.degree,3),m,1) # furhter measure of in-degree heterogeneity
out.three.star <- matrix( choose(out.degree,3),m,1) # furhter measure of out-degree heterogeneity
triangles <- rowSums( adj.lefttroll* (adj.lefttroll %*% t(adj.lefttroll) )  ) # embedded in transitive triads
## Forming a new covs
covs.lefttroll <- cbind(
activity,
maxfollowing,
minfollowing,
maxfollowers,
minfollowers,
in.degree,
out.degree,
rec.ties,
in.two.star,
out.two.star,
mix.two.star,
in.three.star,
out.three.star,
triangles)
colnames(covs.lefttroll) <- c(
"activity",
"maxfollowing",
"minfollowing",
"maxfollowers",
"minfollowers",
"indegree",
"outdegree",
"reciprocation" ,
"instar",
"outstar",
"twopath",
"in3star",
"out3star",
"transitive")
head(covs.lefttroll)
# creating measure of dv
fg.lefttroll <- maxfollowers - minfollowers
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
str(fg.lefttroll)
fg.lefttroll[fg.lefttroll<392] <- 0
fg.lefttroll[fg.lefttroll>=392] <- 1
summary(fg.lefttroll)
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
# creating measure of dv
fg.lefttroll <- maxfollowers - minfollowers
summary(fg.lefttroll) # the mean is 2719,but the median is 19.
summary(fg.lefttroll) # the mean is 2330,but the median is 392.
str(fg.lefttroll)
fg.lefttroll[fg.lefttroll<392] <- 0
fg.lefttroll[fg.lefttroll>=392] <- 1
str(fg.lefttroll)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 10,000,   # number of iterations
saveFreq = 500)   # print and save frequency
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.lt$Thetas)
res.lt <- BayesALAAM(y = fg.lefttroll, # median-based dependent variable
ADJ = adj.lefttroll,           # network
covariates = covs.lefttroll[,c(1,6,7,8,11,14)],   # covariates
directed = TRUE,     # directed / undirecred network
Iterations = 10000,   # number of iterations
saveFreq = 500)   # print and save frequency
## results not good enough
## you can improve the mixing by using a better proposal covariance
Propsigma <- cov(res.lt$Thetas)
